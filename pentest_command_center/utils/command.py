import os
import subprocess
import sys
import json
import time
import logging
import asyncio
from typing import Dict, List, Any, Optional, Tuple, Union

# Add parent directory to path so we can import from config
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
from config.settings import LOGS_DIR

# Set up logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler(os.path.join(LOGS_DIR, 'commands.log')),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger("command_executor")

class CommandExecutor:
    """Executes system commands and handles the results."""
    
    def __init__(self):
        """Initialize the command executor."""
        self.command_history = []
    
    def run_command(self, command: str, timeout: int = 600) -> Dict[str, Any]:
        """
        Run a system command and return the result.
        
        Args:
            command: The command to execute
            timeout: Maximum time to wait for command completion in seconds
            
        Returns:
            Dictionary containing command results
        """
        start_time = time.time()
        result = {
            "command": command,
            "start_time": start_time,
            "success": False,
            "stdout": "",
            "stderr": "",
            "duration": 0,
            "exit_code": None
        }
        
        logger.info(f"Executing command: {command}")
        
        try:
            # Run the command with timeout
            process = subprocess.Popen(
                command,
                shell=True,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                text=True
            )
            
            try:
                stdout, stderr = process.communicate(timeout=timeout)
                exit_code = process.returncode
                
                result["stdout"] = stdout
                result["stderr"] = stderr
                result["exit_code"] = exit_code
                result["success"] = exit_code == 0
                
            except subprocess.TimeoutExpired:
                process.kill()
                result["stderr"] = f"Command timed out after {timeout} seconds"
                logger.warning(f"Command timed out: {command}")
                
        except Exception as e:
            result["stderr"] = str(e)
            logger.error(f"Error executing command: {e}")
        
        # Calculate duration
        result["duration"] = time.time() - start_time
        
        # Add to history
        self.command_history.append(result)
        
        return result
    
    async def run_command_async(self, command: str, timeout: int = 600) -> Dict[str, Any]:
        """
        Run a system command asynchronously and return the result.
        
        Args:
            command: The command to execute
            timeout: Maximum time to wait for command completion in seconds
            
        Returns:
            Dictionary containing command results
        """
        start_time = time.time()
        result = {
            "command": command,
            "start_time": start_time,
            "success": False,
            "stdout": "",
            "stderr": "",
            "duration": 0,
            "exit_code": None
        }
        
        logger.info(f"Executing async command: {command}")
        
        try:
            # Create subprocess
            process = await asyncio.create_subprocess_shell(
                command,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE
            )
            
            try:
                # Wait for the process to complete with timeout
                stdout_bytes, stderr_bytes = await asyncio.wait_for(
                    process.communicate(), 
                    timeout=timeout
                )
                
                result["stdout"] = stdout_bytes.decode()
                result["stderr"] = stderr_bytes.decode()
                result["exit_code"] = process.returncode
                result["success"] = process.returncode == 0
                
            except asyncio.TimeoutError:
                # Kill the process if it times out
                try:
                    process.kill()
                except ProcessLookupError:
                    pass
                    
                result["stderr"] = f"Command timed out after {timeout} seconds"
                logger.warning(f"Async command timed out: {command}")
                
        except Exception as e:
            result["stderr"] = str(e)
            logger.error(f"Error executing async command: {e}")
        
        # Calculate duration
        result["duration"] = time.time() - start_time
        
        # Add to history
        self.command_history.append(result)
        
        return result
    
    def is_tool_installed(self, tool_name: str) -> bool:
        """
        Check if a tool is installed and available in the system.
        
        Args:
            tool_name: Name of the tool to check
            
        Returns:
            True if the tool is installed, False otherwise
        """
        result = self.run_command(f"which {tool_name}")
        return result["success"]
    
    def get_command_history(self, limit: Optional[int] = None) -> List[Dict[str, Any]]:
        """
        Get the command execution history.
        
        Args:
            limit: Maximum number of history items to return
            
        Returns:
            List of command execution results
        """
        if limit:
            return self.command_history[-limit:]
        return self.command_history
    
    def parse_command_output(self, output: str, parser_type: str) -> Dict[str, Any]:
        """
        Parse command output based on the parser type.
        
        Args:
            output: Command output text
            parser_type: Type of parser to use (json, nmap, etc.)
            
        Returns:
            Parsed data as a dictionary
        """
        if parser_type == "json":
            try:
                return json.loads(output)
            except json.JSONDecodeError:
                logger.error("Failed to parse JSON output")
                return {"error": "Invalid JSON output", "raw": output}
                
        elif parser_type == "nmap":
            # Basic Nmap parser (could be enhanced for more detailed parsing)
            results = {"hosts": []}
            current_host = None
            
            for line in output.split('\n'):
                line = line.strip()
                
                # Check for host entries
                if line.startswith("Nmap scan report for"):
                    if current_host:
                        results["hosts"].append(current_host)
                    
                    # Extract hostname/IP
                    host_info = line.replace("Nmap scan report for", "").strip()
                    current_host = {"host": host_info, "ports": []}
                
                # Check for port entries
                elif current_host and line and "/tcp" in line or "/udp" in line:
                    parts = line.split()
                    if len(parts) >= 3:
                        port_info = parts[0]
                        state = parts[1]
                        service = " ".join(parts[2:])
                        
                        current_host["ports"].append({
                            "port": port_info,
                            "state": state,
                            "service": service
                        })
            
            # Add the last host if exists
            if current_host:
                results["hosts"].append(current_host)
                
            return results
            
        # Add more parsers as needed
        
        # Default: return as raw text
        return {"raw": output}

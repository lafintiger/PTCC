import os
import sys
import json
import time
import ipaddress
from typing import Dict, List, Any, Optional, Union
import matplotlib.pyplot as plt
import matplotlib.colors as mcolors
import matplotlib.patches as mpatches
import networkx as nx
import pandas as pd
import numpy as np
from io import BytesIO

# Add parent directory to path so we can import from config
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

class VisualizationHelper:
    """Generates visualizations for penetration test data."""
    
    def __init__(self):
        """Initialize the visualization helper."""
        # Set default style for plots
        plt.style.use('ggplot')
    
    def generate_network_map(self, network_data: Dict[str, Any]) -> plt.Figure:
        """
        Generate a network map visualization from network scan data.
        
        Args:
            network_data: Dictionary containing network scan results
            
        Returns:
            Matplotlib figure with the network map
        """
        # Create a new graph
        G = nx.Graph()
        
        # Track service types for coloring
        service_types = set()
        
        # Extract hosts and add them as nodes
        if "hosts" in network_data:
            hosts = network_data["hosts"]
            
            # Check if we actually have hosts
            if not hosts:
                # Return empty figure with a message
                fig, ax = plt.subplots(figsize=(10, 6))
                ax.text(0.5, 0.5, "No hosts found in scan data", 
                        horizontalalignment='center', verticalalignment='center',
                        transform=ax.transAxes, fontsize=14)
                ax.axis('off')
                return fig
            
            # Categorize hosts by subnet
            subnets = {}
            
            for host_ip, host_info in hosts.items():
                # Get host state
                state = host_info.get("state", "unknown")
                
                # Skip hosts that are down
                if state.lower() != "up":
                    continue
                
                # Add host as node
                hostname = host_info.get("hostname", "")
                label = f"{host_ip}\n{hostname}" if hostname else host_ip
                
                # Determine subnet (for clustering)
                try:
                    ip = ipaddress.ip_address(host_ip)
                    # For IPv4, use first 3 octets as subnet identifier
                    if isinstance(ip, ipaddress.IPv4Address):
                        subnet = '.'.join(host_ip.split('.')[:3])
                    # For IPv6, use first 4 hextets
                    else:
                        subnet = ':'.join(host_ip.split(':')[:4])
                    
                    if subnet not in subnets:
                        subnets[subnet] = []
                    subnets[subnet].append(host_ip)
                except ValueError:
                    # Not a valid IP address (maybe a hostname)
                    subnet = "unknown"
                
                # Count open ports
                open_ports = [p for p in host_info.get("ports", []) if p.get("state") == "open"]
                
                # Add node with attributes
                G.add_node(host_ip, 
                           label=label, 
                           state=state,
                           hostname=hostname,
                           ports=len(open_ports),
                           subnet=subnet)
                
                # Add service nodes for each open port
                for port in open_ports:
                    port_num = port.get("port", "")
                    protocol = port.get("protocol", "")
                    service = port.get("service", "")
                    product = port.get("product", "")
                    
                    # Create a service node ID
                    service_id = f"{service}_{port_num}_{protocol}"
                    service_label = f"{service} ({port_num}/{protocol})"
                    
                    # Add to service types set
                    service_types.add(service)
                    
                    # Add service node if it doesn't exist yet
                    if not G.has_node(service_id):
                        G.add_node(service_id, 
                                  label=service_label,
                                  type="service",
                                  service=service,
                                  port=port_num,
                                  protocol=protocol)
                    
                    # Connect host to service
                    G.add_edge(host_ip, service_id, weight=1)
        
        # Create figure and axis
        fig, ax = plt.subplots(figsize=(12, 8))
        
        # Set a position layout
        if len(G.nodes) > 1:
            # Use spring layout with some grouping by subnet
            pos = nx.spring_layout(G, seed=42)
            
            # Create color map for services
            service_colors = {}
            colormap = plt.cm.tab20
            for i, service in enumerate(service_types):
                service_colors[service] = colormap(i % 20)
            
            # Draw nodes
            for node in G.nodes:
                if G.nodes[node].get("type") == "service":
                    # Service node - color by service type
                    service = G.nodes[node].get("service", "")
                    color = service_colors.get(service, "gray")
                    nx.draw_networkx_nodes(G, pos, nodelist=[node], node_color=[color], 
                                          node_size=300, alpha=0.7, ax=ax)
                else:
                    # Host node - size by number of open ports
                    ports = G.nodes[node].get("ports", 0)
                    size = max(300, ports * 50)  # Minimum size of 300
                    nx.draw_networkx_nodes(G, pos, nodelist=[node], node_color="skyblue", 
                                          node_size=size, alpha=0.9, ax=ax)
            
            # Draw edges
            nx.draw_networkx_edges(G, pos, width=1.0, alpha=0.5, ax=ax)
            
            # Draw labels
            nx.draw_networkx_labels(G, pos, font_size=8, font_family="sans-serif", ax=ax)
            
            # Create legend for services
            legend_handles = []
            for service, color in service_colors.items():
                legend_handles.append(mpatches.Patch(color=color, label=service))
            
            if legend_handles:
                ax.legend(handles=legend_handles, loc='upper right', title="Services")
            
            # Set title and remove axis
            scan_info = network_data.get("scan_info", {})
            target = scan_info.get("target", "Unknown")
            timestamp = scan_info.get("timestamp", "Unknown")
            ax.set_title(f"Network Map for {target} - {timestamp}")
            
        else:
            # If only one or zero nodes, display a message
            ax.text(0.5, 0.5, "Insufficient data for network map", 
                    horizontalalignment='center', verticalalignment='center',
                    transform=ax.transAxes, fontsize=14)
        
        ax.axis('off')
        plt.tight_layout()
        
        return fig
    
    def generate_port_distribution(self, network_data: Dict[str, Any]) -> plt.Figure:
        """
        Generate a port distribution visualization.
        
        Args:
            network_data: Dictionary containing network scan results
            
        Returns:
            Matplotlib figure showing port distribution
        """
        # Extract ports from hosts
        port_data = []
        
        if "hosts" in network_data:
            hosts = network_data["hosts"]
            
            for host_ip, host_info in hosts.items():
                for port in host_info.get("ports", []):
                    if port.get("state") == "open":
                        port_data.append({
                            "host": host_ip,
                            "port": port.get("port", ""),
                            "protocol": port.get("protocol", ""),
                            "service": port.get("service", "")
                        })
        
        # If no port data, return empty figure with message
        if not port_data:
            fig, ax = plt.subplots(figsize=(10, 6))
            ax.text(0.5, 0.5, "No open ports found in scan data", 
                    horizontalalignment='center', verticalalignment='center',
                    transform=ax.transAxes, fontsize=14)
            ax.axis('off')
            return fig
        
        # Convert to DataFrame
        df = pd.DataFrame(port_data)
        
        # Create figure
        fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(15, 7))
        
        # Top services bar chart
        service_counts = df["service"].value_counts().head(10)
        service_counts.plot(kind="barh", ax=ax1, color="lightblue")
        ax1.set_title("Top 10 Services")
        ax1.set_xlabel("Count")
        ax1.set_ylabel("Service")
        
        # Port frequency histogram
        try:
            # Convert ports to integers for histogram
            ports = pd.to_numeric(df["port"], errors="coerce").dropna()
            ax2.hist(ports, bins=30, alpha=0.7, color="lightblue")
            ax2.set_title("Port Distribution")
            ax2.set_xlabel("Port Number")
            ax2.set_ylabel("Frequency")
            
            # Annotate well-known ports
            well_known_ports = {
                22: "SSH",
                80: "HTTP",
                443: "HTTPS",
                21: "FTP",
                23: "Telnet",
                25: "SMTP",
                53: "DNS",
                3389: "RDP",
                445: "SMB",
                139: "NetBIOS"
            }
            
            for port in well_known_ports:
                if port in ports.values:
                    ax2.axvline(port, color="red", linestyle="--", alpha=0.6)
                    ax2.text(port, ax2.get_ylim()[1] * 0.9, well_known_ports[port], 
                            rotation=90, verticalalignment="top", fontsize=8)
            
        except Exception as e:
            ax2.text(0.5, 0.5, f"Error generating port histogram: {str(e)}", 
                    horizontalalignment='center', verticalalignment='center',
                    transform=ax2.transAxes, fontsize=12)
        
        # Set overall title
        scan_info = network_data.get("scan_info", {})
        target = scan_info.get("target", "Unknown")
        plt.suptitle(f"Port Analysis for {target}", fontsize=16)
        
        plt.tight_layout()
        fig.subplots_adjust(top=0.9)
        
        return fig
    
    def generate_vulnerability_severity_chart(self, vuln_data: Dict[str, Any]) -> plt.Figure:
        """
        Generate a vulnerability severity chart.
        
        Args:
            vuln_data: Dictionary containing vulnerability scan results
            
        Returns:
            Matplotlib figure showing vulnerability severity distribution
        """
        # Extract findings
        findings = vuln_data.get("findings", [])
        
        # If no findings, return empty figure with message
        if not findings:
            fig, ax = plt.subplots(figsize=(10, 6))
            ax.text(0.5, 0.5, "No vulnerabilities found in scan data", 
                    horizontalalignment='center', verticalalignment='center',
                    transform=ax.transAxes, fontsize=14)
            ax.axis('off')
            return fig
        
        # Count by severity
        severity_counts = {"critical": 0, "high": 0, "medium": 0, "low": 0, "info": 0}
        
        for finding in findings:
            severity = finding.get("info", {}).get("severity", "").lower()
            if severity in severity_counts:
                severity_counts[severity] += 1
            else:
                # Handle non-standard severity levels
                severity_counts["info"] += 1
        
        # Create figure
        fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(15, 7))
        
        # Bar chart
        severities = ["critical", "high", "medium", "low", "info"]
        colors = ["darkred", "red", "orange", "yellow", "blue"]
        
        # Filter out zero counts
        data = [severity_counts[s] for s in severities]
        non_zero_indices = [i for i, count in enumerate(data) if count > 0]
        
        if non_zero_indices:
            # Only plot non-zero values
            non_zero_severities = [severities[i] for i in non_zero_indices]
            non_zero_data = [data[i] for i in non_zero_indices]
            non_zero_colors = [colors[i] for i in non_zero_indices]
            
            ax1.bar(non_zero_severities, non_zero_data, color=non_zero_colors)
            ax1.set_title("Vulnerability Severity Distribution")
            ax1.set_xlabel("Severity")
            ax1.set_ylabel("Count")
            
            for i, v in enumerate(non_zero_data):
                ax1.text(i, v + 0.1, str(v), ha='center')
            
            # Pie chart
            ax2.pie(non_zero_data, labels=non_zero_severities, colors=non_zero_colors, 
                   autopct='%1.1f%%', startangle=90, shadow=True)
            ax2.axis('equal')
            ax2.set_title("Severity Breakdown")
            
        else:
            # If all counts are zero, display a message
            for ax in [ax1, ax2]:
                ax.text(0.5, 0.5, "No vulnerability data to display", 
                       horizontalalignment='center', verticalalignment='center',
                       transform=ax.transAxes, fontsize=14)
                ax.axis('off')
        
        # Set overall title
        scan_info = vuln_data.get("scan_info", {})
        target = scan_info.get("target", "Unknown")
        plt.suptitle(f"Vulnerability Analysis for {target}", fontsize=16)
        
        plt.tight_layout()
        fig.subplots_adjust(top=0.9)
        
        return fig
    
    def save_figure(self, fig: plt.Figure, filename: str, dpi: int = 300) -> str:
        """
        Save a figure to a file.
        
        Args:
            fig: Matplotlib figure to save
            filename: Filename to save as
            dpi: Resolution (dots per inch)
            
        Returns:
            Path to the saved figure
        """
        # Ensure the file has an extension
        if not any(filename.endswith(ext) for ext in ['.png', '.jpg', '.jpeg', '.pdf', '.svg']):
            filename += '.png'
        
        # Save the figure
        fig.savefig(filename, dpi=dpi, bbox_inches='tight')
        
        return filename
    
    def figure_to_bytes(self, fig: plt.Figure, format: str = 'png', dpi: int = 150) -> bytes:
        """
        Convert a matplotlib figure to bytes.
        
        Args:
            fig: Matplotlib figure
            format: Image format (png, jpg, etc.)
            dpi: Resolution (dots per inch)
            
        Returns:
            Image bytes
        """
        buf = BytesIO()
        fig.savefig(buf, format=format, dpi=dpi, bbox_inches='tight')
        buf.seek(0)
        return buf.getvalue()

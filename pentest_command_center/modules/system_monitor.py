import os
import time
import threading
import queue
import psutil
import json
from datetime import datetime
import logging
from typing import Dict, List, Any, Optional

# Add parent directory to path so we can import from config
import sys
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
from config.settings import DATA_DIR

class SystemMonitor:
    """
    Monitors system resources and active tasks
    """
    
    def __init__(self, data_dir: str):
        self.data_dir = data_dir
        self.history_dir = os.path.join(data_dir, "monitor_history")
        self.active_tasks = {}
        self.stats_queue = queue.Queue()
        self.running = False
        self.monitor_thread = None
        self.logger = logging.getLogger("system_monitor")
        self.max_history_points = 100
        self.history = {
            "cpu": [],
            "memory": [],
            "disk": [],
            "tasks": []
        }
        
        # Create history directory if it doesn't exist
        os.makedirs(self.history_dir, exist_ok=True)
        
    def start_monitoring(self):
        """Start the monitoring thread"""
        if self.running:
            return False
            
        self.running = True
        self.monitor_thread = threading.Thread(target=self._monitor_loop, daemon=True)
        self.monitor_thread.start()
        self.logger.info("System monitoring started")
        return True
        
    def stop_monitoring(self):
        """Stop the monitoring thread"""
        self.running = False
        if self.monitor_thread:
            self.monitor_thread.join(timeout=2)
            self.logger.info("System monitoring stopped")
        return True
    
    def _monitor_loop(self):
        """Main monitoring loop, collects system stats regularly"""
        while self.running:
            try:
                # Collect system stats
                stats = self._collect_system_stats()
                
                # Update history
                self._update_history(stats)
                
                # Add to queue for real-time updates
                self.stats_queue.put(stats)
                
                # Save history periodically (every 10 samples)
                if len(self.history["cpu"]) % 10 == 0:
                    self._save_history()
                
                # Sleep before next collection
                time.sleep(2)
                
            except Exception as e:
                self.logger.error(f"Error in monitoring loop: {e}")
                time.sleep(5)  # Sleep longer on error
    
    def _collect_system_stats(self):
        """Collect current system statistics"""
        timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        
        # CPU usage
        cpu_usage = psutil.cpu_percent(interval=0.5)
        
        # Memory usage
        memory = psutil.virtual_memory()
        memory_usage = memory.percent
        memory_used = memory.used / (1024 * 1024 * 1024)  # Convert to GB
        memory_total = memory.total / (1024 * 1024 * 1024)  # Convert to GB
        
        # Disk usage
        disk = psutil.disk_usage(self.data_dir)
        disk_usage = disk.percent
        disk_used = disk.used / (1024 * 1024 * 1024)  # Convert to GB
        disk_total = disk.total / (1024 * 1024 * 1024)  # Convert to GB
        
        # Network IO
        network = psutil.net_io_counters()
        
        # Active tasks summary
        active_task_count = len(self.active_tasks)
        task_summary = self._get_task_summary()
        
        # System load (1, 5, 15 minute averages)
        load_avg = [0, 0, 0]  # Default for Windows
        if hasattr(os, 'getloadavg'):
            try:
                load_avg = os.getloadavg()
            except:
                pass
        
        # Combine into stats dictionary
        stats = {
            "timestamp": timestamp,
            "cpu": {
                "percent": cpu_usage
            },
            "memory": {
                "percent": memory_usage,
                "used_gb": round(memory_used, 2),
                "total_gb": round(memory_total, 2)
            },
            "disk": {
                "percent": disk_usage,
                "used_gb": round(disk_used, 2),
                "total_gb": round(disk_total, 2)
            },
            "network": {
                "bytes_sent": network.bytes_sent,
                "bytes_recv": network.bytes_recv
            },
            "tasks": {
                "count": active_task_count,
                "summary": task_summary
            },
            "load": {
                "1min": round(load_avg[0], 2),
                "5min": round(load_avg[1], 2),
                "15min": round(load_avg[2], 2)
            }
        }
        
        return stats
    
    def _update_history(self, stats):
        """Update the history with new stats"""
        timestamp = stats["timestamp"]
        
        # Add to CPU history
        self.history["cpu"].append({
            "timestamp": timestamp,
            "value": stats["cpu"]["percent"]
        })
        
        # Add to memory history
        self.history["memory"].append({
            "timestamp": timestamp,
            "value": stats["memory"]["percent"]
        })
        
        # Add to disk history
        self.history["disk"].append({
            "timestamp": timestamp,
            "value": stats["disk"]["percent"]
        })
        
        # Add to tasks history
        self.history["tasks"].append({
            "timestamp": timestamp,
            "value": stats["tasks"]["count"]
        })
        
        # Trim histories to max length
        for key in self.history:
            if len(self.history[key]) > self.max_history_points:
                self.history[key] = self.history[key][-self.max_history_points:]
    
    def _save_history(self):
        """Save monitoring history to file"""
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        history_file = os.path.join(self.history_dir, f"monitor_history_{timestamp}.json")
        
        try:
            with open(history_file, 'w') as f:
                json.dump(self.history, f, indent=2)
        except Exception as e:
            self.logger.error(f"Error saving monitoring history: {e}")
    
    def _get_task_summary(self):
        """Get a summary of active tasks"""
        task_types = {}
        for task_id, task in self.active_tasks.items():
            task_type = task.get("type", "unknown")
            if task_type in task_types:
                task_types[task_type] += 1
            else:
                task_types[task_type] = 1
        
        return task_types
    
    def get_latest_stats(self):
        """Get the latest system stats"""
        try:
            # Non-blocking get from queue
            return self.stats_queue.get(block=False)
        except queue.Empty:
            # If queue is empty (no recent stats), collect them now
            return self._collect_system_stats()
    
    def get_history(self):
        """Get the monitoring history"""
        return self.history
    
    def add_task(self, task_id: str, task_type: str, task_name: str, target: str = ""):
        """
        Add a task to be monitored
        
        Args:
            task_id: Unique identifier for the task
            task_type: Type of task (scan, exploit, etc.)
            task_name: Human-readable name of the task
            target: Optional target of the task
        """
        self.active_tasks[task_id] = {
            "id": task_id,
            "type": task_type,
            "name": task_name,
            "target": target,
            "status": "running",
            "progress": 0,
            "start_time": datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
            "last_update": datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        }
        return self.active_tasks[task_id]
    
    def update_task(self, task_id: str, status: Optional[str] = None, 
                   progress: Optional[int] = None, message: Optional[str] = None):
        """
        Update the status of a monitored task
        
        Args:
            task_id: ID of the task to update
            status: New status (running, completed, failed, etc.)
            progress: Progress percentage (0-100)
            message: Optional status message
        """
        if task_id not in self.active_tasks:
            return False
        
        if status:
            self.active_tasks[task_id]["status"] = status
        
        if progress is not None:
            self.active_tasks[task_id]["progress"] = progress
        
        if message:
            self.active_tasks[task_id]["message"] = message
        
        self.active_tasks[task_id]["last_update"] = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        
        # If task is completed or failed, move to history after some time
        if status in ["completed", "failed"] and len(self.active_tasks) > 20:
            # Keep only the 20 most recent completed/failed tasks
            to_remove = []
            for tid, task in self.active_tasks.items():
                if task["status"] in ["completed", "failed"]:
                    to_remove.append(tid)
            
            # Sort by last_update and keep the 5 most recent
            to_remove.sort(key=lambda tid: self.active_tasks[tid]["last_update"], reverse=True)
            for tid in to_remove[5:]:
                del self.active_tasks[tid]
        
        return self.active_tasks[task_id]
    
    def remove_task(self, task_id: str):
        """Remove a task from monitoring"""
        if task_id in self.active_tasks:
            del self.active_tasks[task_id]
            return True
        return False
    
    def get_tasks(self):
        """Get all active tasks"""
        return self.active_tasks
    
    def get_task(self, task_id: str):
        """Get a specific task by ID"""
        return self.active_tasks.get(task_id)
    
    def get_resource_alerts(self):
        """Check for resource usage alerts"""
        alerts = []
        stats = self.get_latest_stats()
        
        # CPU alert (>90%)
        if stats["cpu"]["percent"] > 90:
            alerts.append({
                "level": "critical",
                "type": "cpu",
                "message": f"High CPU usage: {stats['cpu']['percent']}%"
            })
        elif stats["cpu"]["percent"] > 75:
            alerts.append({
                "level": "warning",
                "type": "cpu",
                "message": f"Elevated CPU usage: {stats['cpu']['percent']}%"
            })
        
        # Memory alert (>90%)
        if stats["memory"]["percent"] > 90:
            alerts.append({
                "level": "critical",
                "type": "memory",
                "message": f"High memory usage: {stats['memory']['percent']}%"
            })
        elif stats["memory"]["percent"] > 75:
            alerts.append({
                "level": "warning",
                "type": "memory",
                "message": f"Elevated memory usage: {stats['memory']['percent']}%"
            })
        
        # Disk alert (>90%)
        if stats["disk"]["percent"] > 90:
            alerts.append({
                "level": "critical",
                "type": "disk",
                "message": f"Low disk space: {stats['disk']['percent']}% used"
            })
        elif stats["disk"]["percent"] > 75:
            alerts.append({
                "level": "warning",
                "type": "disk",
                "message": f"Disk space concern: {stats['disk']['percent']}% used"
            })
        
        return alerts 
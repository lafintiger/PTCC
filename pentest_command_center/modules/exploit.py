import sys
import os
import json
import time
import re
import asyncio
from typing import Dict, List, Any, Optional, Union
import logging

# Add parent directory to path so we can import from config and utils
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
from config.settings import (
    SCAN_RESULTS_DIR, METASPLOIT_RPC_HOST, 
    METASPLOIT_RPC_PORT, METASPLOIT_USERNAME, 
    METASPLOIT_PASSWORD
)
from utils.command import CommandExecutor

# Set up logging
logger = logging.getLogger("exploit_module")

class ExploitManager:
    """
    Handles exploitation operations using frameworks like Metasploit.
    """
    
    def __init__(self):
        """Initialize the exploitation manager."""
        self.command_executor = CommandExecutor()
        self.msf_client = None
        self.session_results = {}
    
    async def initialize_metasploit(self) -> Dict[str, Any]:
        """
        Initialize the Metasploit RPC client.
        
        Returns:
            Status of the initialization
        """
        try:
            # Check if pymetasploit3 is available
            try:
                from pymetasploit3.msfrpc import MsfRpcClient
                
                # Start msfrpcd if not already running
                msfrpcd_check = await self.command_executor.run_command_async("ps aux | grep msfrpcd | grep -v grep")
                
                if not msfrpcd_check["stdout"].strip():
                    # Start msfrpcd
                    start_cmd = f"msfrpcd -P {METASPLOIT_PASSWORD} -S -a {METASPLOIT_RPC_HOST} -p {METASPLOIT_RPC_PORT}"
                    result = await self.command_executor.run_command_async(start_cmd)
                    
                    if not result["success"]:
                        return {
                            "success": False,
                            "error": f"Failed to start msfrpcd: {result['stderr']}",
                            "raw_command": result
                        }
                    
                    # Wait for the service to start
                    await asyncio.sleep(5)
                
                # Connect to RPC server
                self.msf_client = MsfRpcClient(
                    METASPLOIT_PASSWORD,
                    server=METASPLOIT_RPC_HOST,
                    port=METASPLOIT_RPC_PORT,
                    username=METASPLOIT_USERNAME,
                    ssl=False
                )
                
                return {
                    "success": True,
                    "message": "Metasploit RPC client initialized successfully",
                    "version": self.msf_client.core.version()
                }
                
            except ImportError:
                return {
                    "success": False,
                    "error": "pymetasploit3 is not installed. Please install it to use Metasploit integration."
                }
                
        except Exception as e:
            return {
                "success": False,
                "error": f"Error initializing Metasploit RPC client: {str(e)}"
            }
    
    async def search_metasploit_exploits(self, query: str) -> Dict[str, Any]:
        """
        Search for exploits in Metasploit.
        
        Args:
            query: Search query
            
        Returns:
            Search results
        """
        # Check if msf_client is initialized
        if not self.msf_client:
            # Try to initialize
            init_result = await self.initialize_metasploit()
            if not init_result["success"]:
                return init_result
        
        try:
            # Search for exploits using the query
            search_results = self.msf_client.modules.search(query)
            
            # Format the results
            formatted_results = []
            for result in search_results:
                formatted_results.append({
                    "name": result.get("name", ""),
                    "fullname": result.get("fullname", ""),
                    "rank": result.get("rank", ""),
                    "disclosure_date": result.get("disclosure_date", ""),
                    "type": result.get("type", ""),
                    "description": result.get("description", "")
                })
            
            # Create result object
            search_result = {
                "scan_info": {
                    "query": query,
                    "tool": "metasploit_search",
                    "timestamp": time.strftime("%Y-%m-%d %H:%M:%S"),
                },
                "results": formatted_results,
                "count": len(formatted_results)
            }
            
            # Save scan result
            scan_id = f"msf_search_{query.replace(' ', '_')}_{int(time.time())}"
            self.session_results[scan_id] = search_result
            
            # Save to file
            self._save_result(scan_id, search_result)
            
            return search_result
            
        except Exception as e:
            logger.error(f"Error searching Metasploit exploits: {e}")
            # Try command line approach as fallback
            return await self._search_metasploit_cli(query)
    
    async def _search_metasploit_cli(self, query: str) -> Dict[str, Any]:
        """
        Search for exploits in Metasploit using the command line interface.
        
        Args:
            query: Search query
            
        Returns:
            Search results
        """
        # Build command
        command = f"msfconsole -q -x 'search {query}; exit'"
        
        # Execute command
        result = await self.command_executor.run_command_async(command)
        
        if result["success"]:
            # Parse the output
            parsed_results = self._parse_msf_search_output(result["stdout"])
            
            # Create result object
            search_result = {
                "scan_info": {
                    "query": query,
                    "tool": "metasploit_search_cli",
                    "timestamp": time.strftime("%Y-%m-%d %H:%M:%S"),
                },
                "results": parsed_results,
                "count": len(parsed_results),
                "raw_command": result
            }
            
            # Save scan result
            scan_id = f"msf_search_cli_{query.replace(' ', '_')}_{int(time.time())}"
            self.session_results[scan_id] = search_result
            
            # Save to file
            self._save_result(scan_id, search_result)
            
            return search_result
            
        else:
            return {
                "success": False,
                "error": f"Metasploit search command failed: {result['stderr']}",
                "scan_info": {
                    "query": query,
                    "tool": "metasploit_search_cli"
                },
                "raw_command": result
            }
    
    def _parse_msf_search_output(self, output: str) -> List[Dict[str, Any]]:
        """
        Parse Metasploit search output into structured data.
        
        Args:
            output: Command output text
            
        Returns:
            Parsed data as list of exploits
        """
        results = []
        
        # Regular expression to match exploit entries
        exploit_pattern = r'\s+(\d+)\s+([\w\d/\.\-\_]+)\s+(\d{4}-\d{2}-\d{2}|n\/a)\s+(\w+)\s+(.+)'
        
        # Split output by lines and find the results section
        lines = output.splitlines()
        parsing_started = False
        
        for line in lines:
            if "Matching Modules" in line:
                parsing_started = True
                continue
                
            if parsing_started and line.strip():
                match = re.search(exploit_pattern, line)
                if match:
                    results.append({
                        "id": match.group(1),
                        "fullname": match.group(2),
                        "disclosure_date": match.group(3),
                        "rank": match.group(4),
                        "name": match.group(5)
                    })
        
        return results
    
    async def run_exploit(self, exploit_path: str, target: str, payload: Optional[str] = None, options: Optional[Dict[str, str]] = None) -> Dict[str, Any]:
        """
        Run a Metasploit exploit.
        
        Args:
            exploit_path: Path to the exploit (e.g., 'exploit/windows/smb/ms17_010_eternalblue')
            target: Target IP or hostname
            payload: Payload to use (e.g., 'windows/x64/meterpreter/reverse_tcp')
            options: Dictionary of options for the exploit
            
        Returns:
            Exploit results
        """
        # Check if msf_client is initialized
        if not self.msf_client:
            # Try to initialize
            init_result = await self.initialize_metasploit()
            if not init_result["success"]:
                return init_result
        
        try:
            # Load the exploit
            exploit = self.msf_client.modules.use('exploit', exploit_path)
            
            # Set target
            exploit['RHOSTS'] = target
            
            # Set payload if provided
            if payload:
                exploit.target = payload
            
            # Set additional options if provided
            if options:
                for key, value in options.items():
                    exploit[key] = value
            
            # Print exploit options for reference
            exploit_options = exploit.options
            formatted_options = {}
            for name, properties in exploit_options.items():
                formatted_options[name] = {
                    "required": properties.get("required", False),
                    "value": exploit[name] if name in exploit else "",
                    "description": properties.get("desc", "")
                }
            
            # Execute the exploit
            exploit_job = exploit.execute()
            
            # Create result object
            exploit_result = {
                "scan_info": {
                    "exploit": exploit_path,
                    "target": target,
                    "payload": payload,
                    "options": options,
                    "timestamp": time.strftime("%Y-%m-%d %H:%M:%S"),
                },
                "results": {
                    "job_id": exploit_job,
                    "options": formatted_options
                }
            }
            
            # Save scan result
            scan_id = f"msf_exploit_{exploit_path.split('/')[-1]}_{target.replace('.', '_')}_{int(time.time())}"
            self.session_results[scan_id] = exploit_result
            
            # Save to file
            self._save_result(scan_id, exploit_result)
            
            return exploit_result
            
        except Exception as e:
            logger.error(f"Error running Metasploit exploit: {e}")
            # Try command line approach as fallback
            return await self._run_exploit_cli(exploit_path, target, payload, options)
    
    async def _run_exploit_cli(self, exploit_path: str, target: str, payload: Optional[str] = None, options: Optional[Dict[str, str]] = None) -> Dict[str, Any]:
        """
        Run a Metasploit exploit using the command line interface.
        
        Args:
            exploit_path: Path to the exploit (e.g., 'exploit/windows/smb/ms17_010_eternalblue')
            target: Target IP or hostname
            payload: Payload to use (e.g., 'windows/x64/meterpreter/reverse_tcp')
            options: Dictionary of options for the exploit
            
        Returns:
            Exploit results
        """
        # Build resource script for Metasploit
        resource_file = f"/tmp/msf_resource_{int(time.time())}.rc"
        
        script_lines = [
            f"use {exploit_path}",
            f"set RHOSTS {target}"
        ]
        
        if payload:
            script_lines.append(f"set PAYLOAD {payload}")
        
        if options:
            for key, value in options.items():
                script_lines.append(f"set {key} {value}")
        
        script_lines.append("exploit -j")
        script_lines.append("sleep 5")
        script_lines.append("sessions -l")
        script_lines.append("exit")
        
        # Write resource script to file
        with open(resource_file, 'w') as f:
            f.write("\n".join(script_lines))
        
        # Build command to run Metasploit with resource script
        command = f"msfconsole -q -r {resource_file}"
        
        # Execute command
        result = await self.command_executor.run_command_async(command)
        
        # Clean up resource file
        try:
            os.remove(resource_file)
        except:
            pass
        
        if result["success"]:
            # Parse the output to check if any sessions were established
            sessions = []
            
            # Simple regex to find session listings
            session_pattern = r'(\d+)\s+([^\s]+)\s+([^\s]+)\s+([^\s]+)\s+(.+)'
            
            for line in result["stdout"].splitlines():
                if "Active sessions" in line:
                    continue
                
                match = re.search(session_pattern, line)
                if match:
                    sessions.append({
                        "id": match.group(1),
                        "name": match.group(2),
                        "type": match.group(3),
                        "target": match.group(4),
                        "info": match.group(5)
                    })
            
            # Create result object
            exploit_result = {
                "scan_info": {
                    "exploit": exploit_path,
                    "target": target,
                    "payload": payload,
                    "options": options,
                    "timestamp": time.strftime("%Y-%m-%d %H:%M:%S"),
                },
                "results": {
                    "sessions": sessions,
                    "session_count": len(sessions)
                },
                "raw_command": result
            }
            
            # Save scan result
            scan_id = f"msf_exploit_cli_{exploit_path.split('/')[-1]}_{target.replace('.', '_')}_{int(time.time())}"
            self.session_results[scan_id] = exploit_result
            
            # Save to file
            self._save_result(scan_id, exploit_result)
            
            return exploit_result
            
        else:
            return {
                "success": False,
                "error": f"Metasploit exploit command failed: {result['stderr']}",
                "scan_info": {
                    "exploit": exploit_path,
                    "target": target,
                    "payload": payload,
                    "options": options
                },
                "raw_command": result
            }
    
    async def list_metasploit_sessions(self) -> Dict[str, Any]:
        """
        List active Metasploit sessions.
        
        Returns:
            List of active sessions
        """
        # Check if msf_client is initialized
        if not self.msf_client:
            # Try to initialize
            init_result = await self.initialize_metasploit()
            if not init_result["success"]:
                return init_result
        
        try:
            # Get sessions
            sessions = self.msf_client.sessions.list
            
            # Format the sessions
            formatted_sessions = []
            for session_id, session_info in sessions.items():
                formatted_sessions.append({
                    "id": session_id,
                    "type": session_info.get("type", ""),
                    "tunnel_local": session_info.get("tunnel_local", ""),
                    "tunnel_peer": session_info.get("tunnel_peer", ""),
                    "via_exploit": session_info.get("via_exploit", ""),
                    "via_payload": session_info.get("via_payload", ""),
                    "info": session_info.get("info", "")
                })
            
            # Create result object
            list_result = {
                "scan_info": {
                    "tool": "metasploit_sessions",
                    "timestamp": time.strftime("%Y-%m-%d %H:%M:%S"),
                },
                "results": formatted_sessions,
                "count": len(formatted_sessions)
            }
            
            return list_result
            
        except Exception as e:
            logger.error(f"Error listing Metasploit sessions: {e}")
            # Try command line approach as fallback
            return await self._list_sessions_cli()
    
    async def _list_sessions_cli(self) -> Dict[str, Any]:
        """
        List active Metasploit sessions using the command line interface.
        
        Returns:
            List of active sessions
        """
        # Build command
        command = "msfconsole -q -x 'sessions -l; exit'"
        
        # Execute command
        result = await self.command_executor.run_command_async(command)
        
        if result["success"]:
            # Parse the output to get active sessions
            sessions = []
            
            # Simple regex to find session listings
            session_pattern = r'(\d+)\s+([^\s]+)\s+([^\s]+)\s+([^\s]+)\s+(.+)'
            
            for line in result["stdout"].splitlines():
                if "Active sessions" in line:
                    continue
                
                match = re.search(session_pattern, line)
                if match:
                    sessions.append({
                        "id": match.group(1),
                        "name": match.group(2),
                        "type": match.group(3),
                        "target": match.group(4),
                        "info": match.group(5)
                    })
            
            # Create result object
            list_result = {
                "scan_info": {
                    "tool": "metasploit_sessions_cli",
                    "timestamp": time.strftime("%Y-%m-%d %H:%M:%S"),
                },
                "results": sessions,
                "count": len(sessions),
                "raw_command": result
            }
            
            return list_result
            
        else:
            return {
                "success": False,
                "error": f"Metasploit sessions command failed: {result['stderr']}",
                "scan_info": {
                    "tool": "metasploit_sessions_cli"
                },
                "raw_command": result
            }
    
    async def run_metasploit_command(self, command: str) -> Dict[str, Any]:
        """
        Run a raw Metasploit console command.
        
        Args:
            command: Metasploit console command
            
        Returns:
            Command output
        """
        # Build resource script for Metasploit
        resource_file = f"/tmp/msf_command_{int(time.time())}.rc"
        
        # Write command to resource file
        with open(resource_file, 'w') as f:
            f.write(f"{command}\nexit")
        
        # Build command to run Metasploit with resource script
        msf_command = f"msfconsole -q -r {resource_file}"
        
        # Execute command
        result = await self.command_executor.run_command_async(msf_command)
        
        # Clean up resource file
        try:
            os.remove(resource_file)
        except:
            pass
        
        # Create result object
        command_result = {
            "scan_info": {
                "command": command,
                "tool": "metasploit_console",
                "timestamp": time.strftime("%Y-%m-%d %H:%M:%S"),
            },
            "success": result["success"],
            "output": result["stdout"],
            "error": result["stderr"],
            "raw_command": result
        }
        
        # Save scan result
        scan_id = f"msf_command_{int(time.time())}"
        self.session_results[scan_id] = command_result
        
        # Save to file
        self._save_result(scan_id, command_result)
        
        return command_result
    
    def get_result(self, result_id: str) -> Optional[Dict[str, Any]]:
        """
        Get a specific result by ID.
        
        Args:
            result_id: ID of the result to retrieve
            
        Returns:
            Result dictionary or None if not found
        """
        return self.session_results.get(result_id)
    
    def get_all_results(self) -> Dict[str, Dict[str, Any]]:
        """
        Get all results.
        
        Returns:
            Dictionary of all results
        """
        return self.session_results
    
    def _save_result(self, result_id: str, result: Dict[str, Any]) -> None:
        """
        Save result to a file.
        
        Args:
            result_id: ID of the result
            result: Result dictionary
        """
        try:
            # Create scan results directory if it doesn't exist
            os.makedirs(SCAN_RESULTS_DIR, exist_ok=True)
            
            # Save scan result to a JSON file
            file_path = os.path.join(SCAN_RESULTS_DIR, f"{result_id}.json")
            with open(file_path, 'w') as f:
                json.dump(result, f, indent=2)
        except Exception as e:
            logger.error(f"Error saving result: {e}")
    
    def load_results(self) -> None:
        """Load all saved results from the scan results directory."""
        try:
            # Check if scan results directory exists
            if not os.path.exists(SCAN_RESULTS_DIR):
                return
            
            # Load all JSON files in the scan results directory
            for filename in os.listdir(SCAN_RESULTS_DIR):
                if filename.endswith(".json") and ("msf_" in filename):
                    file_path = os.path.join(SCAN_RESULTS_DIR, filename)
                    try:
                        with open(file_path, 'r') as f:
                            result = json.load(f)
                            result_id = filename[:-5]  # Remove .json extension
                            self.session_results[result_id] = result
                    except Exception as e:
                        logger.error(f"Error loading result {filename}: {e}")
        except Exception as e:
            logger.error(f"Error loading results: {e}")
    
    async def run_hashcat(self, hash_file: str, hash_type: str, attack_mode: str, 
                     wordlist: str = "", mask: str = "", rules: str = "", 
                     options: Dict[str, str] = None) -> Dict[str, Any]:
        """
        Run Hashcat password cracking tool.
        
        Args:
            hash_file: Path to file containing hashes
            hash_type: Hash type (e.g., "0" for MD5, "1000" for NTLM)
            attack_mode: Attack mode (0=dict, 1=combo, 3=bruteforce, 6=hybrid, 7=hybrid)
            wordlist: Path to wordlist file (for dictionary attacks)
            mask: Mask pattern (for mask attacks)
            rules: Rules to apply
            options: Additional options
            
        Returns:
            Results dictionary
        """
        # Build command
        cmd = ["hashcat"]
        
        # Add hash type
        cmd.extend(["-m", hash_type])
        
        # Add attack mode
        cmd.extend(["-a", attack_mode])
        
        # Add hash file
        cmd.append(hash_file)
        
        # Add wordlist for dictionary attack
        if attack_mode == "0" and wordlist:
            cmd.append(wordlist)
        
        # Add mask for brute force
        if attack_mode == "3" and mask:
            cmd.append(mask)
        
        # Add rules if specified
        if rules:
            cmd.extend(["-r", rules])
        
        # Add additional options
        if options:
            for key, value in options.items():
                if key.startswith("--"):
                    cmd.append(f"{key}={value}")
                else:
                    cmd.extend([f"--{key}", value])
        
        # Execute command
        try:
            process = await asyncio.create_subprocess_exec(
                *cmd,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE
            )
            
            stdout, stderr = await process.communicate()
            
            # Check for errors
            if process.returncode != 0 and process.returncode != 1:  # 1 can mean partially cracked
                return {
                    "error": f"Hashcat process exited with code {process.returncode}: {stderr.decode()}",
                    "command": " ".join(cmd)
                }
            
            # Parse output
            output = stdout.decode()
            cracked_passwords = []
            
            # Extract results (hashcat outputs in hash:password format for cracked passwords)
            for line in output.split("\n"):
                if ":" in line and not line.startswith("#"):
                    parts = line.strip().split(":", 1)
                    if len(parts) == 2:
                        hash_val, password = parts
                        cracked_passwords.append({
                            "hash": hash_val,
                            "password": password
                        })
            
            # Create result object
            result = {
                "tool": "hashcat",
                "hash_file": hash_file,
                "hash_type": hash_type,
                "attack_mode": attack_mode,
                "wordlist": wordlist,
                "mask": mask,
                "rules": rules,
                "timestamp": time.strftime("%Y-%m-%d %H:%M:%S"),
                "cracked_passwords": cracked_passwords,
                "output": output,
                "command": " ".join(cmd)
            }
            
            # Save result
            result_id = f"hashcat_{hash_type}_{int(time.time())}"
            self.session_results[result_id] = result
            self._save_result(result_id, result)
            
            return result
            
        except Exception as e:
            return {
                "error": str(e),
                "tool": "hashcat",
                "command": " ".join(cmd)
            }
    
    async def run_john(self, hash_file: str, format: str = "", wordlist: str = "", 
                      rules: str = "", incremental: str = "", 
                      options: Dict[str, str] = None) -> Dict[str, Any]:
        """
        Run John the Ripper password cracking tool.
        
        Args:
            hash_file: Path to file containing hashes
            format: Hash format (e.g., "md5", "ntlm", "sha256")
            wordlist: Path to wordlist file
            rules: Rules to apply
            incremental: Incremental mode
            options: Additional options
            
        Returns:
            Results dictionary
        """
        # Build command
        cmd = ["john"]
        
        # Add format if specified
        if format:
            cmd.extend(["--format", format])
        
        # Add wordlist if specified
        if wordlist:
            cmd.extend(["--wordlist", wordlist])
        
        # Add rules if specified
        if rules:
            cmd.extend(["--rules", rules])
        
        # Add incremental mode if specified
        if incremental:
            cmd.extend(["--incremental", incremental])
        
        # Add additional options
        if options:
            for key, value in options.items():
                if key.startswith("--"):
                    if value:
                        cmd.append(f"{key}={value}")
                    else:
                        cmd.append(key)
                else:
                    if value:
                        cmd.extend([f"--{key}", value])
                    else:
                        cmd.append(f"--{key}")
        
        # Add hash file
        cmd.append(hash_file)
        
        # Execute command
        try:
            process = await asyncio.create_subprocess_exec(
                *cmd,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE
            )
            
            stdout, stderr = await process.communicate()
            
            # Show cracked passwords
            show_cmd = ["john", "--show", hash_file]
            if format:
                show_cmd.extend(["--format", format])
            
            show_process = await asyncio.create_subprocess_exec(
                *show_cmd,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE
            )
            
            show_stdout, show_stderr = await show_process.communicate()
            
            # Parse output
            output = stdout.decode()
            show_output = show_stdout.decode()
            
            # Extract results from show command
            cracked_passwords = []
            for line in show_output.split("\n"):
                if ":" in line and not line.startswith("#"):
                    parts = line.strip().split(":", 1)
                    if len(parts) >= 2:
                        username_or_hash = parts[0]
                        password = parts[1]
                        cracked_passwords.append({
                            "username_or_hash": username_or_hash,
                            "password": password
                        })
            
            # Create result object
            result = {
                "tool": "john",
                "hash_file": hash_file,
                "format": format,
                "wordlist": wordlist,
                "rules": rules,
                "incremental": incremental,
                "timestamp": time.strftime("%Y-%m-%d %H:%M:%S"),
                "cracked_passwords": cracked_passwords,
                "output": output,
                "show_output": show_output,
                "command": " ".join(cmd)
            }
            
            # Save result
            result_id = f"john_{format or 'auto'}_{int(time.time())}"
            self.session_results[result_id] = result
            self._save_result(result_id, result)
            
            return result
            
        except Exception as e:
            return {
                "error": str(e),
                "tool": "john",
                "command": " ".join(cmd)
            }
    
    async def run_hydra(self, target: str, service: str, 
                       usernames: str = "", passwords: str = "", 
                       username_file: str = "", password_file: str = "",
                       tasks: int = 16, timeout: int = 30,
                       options: Dict[str, str] = None) -> Dict[str, Any]:
        """
        Run Hydra brute force tool.
        
        Args:
            target: Target host or IP
            service: Service to attack (ssh, ftp, http-post-form, etc.)
            usernames: Comma-separated usernames to try
            passwords: Comma-separated passwords to try
            username_file: Path to file containing usernames
            password_file: Path to file containing passwords
            tasks: Number of parallel tasks
            timeout: Connection timeout
            options: Additional options
            
        Returns:
            Results dictionary
        """
        # Build command
        cmd = ["hydra"]
        
        # Add tasks
        cmd.extend(["-t", str(tasks)])
        
        # Add timeout
        cmd.extend(["-w", str(timeout)])
        
        # Add username list
        if username_file:
            cmd.extend(["-L", username_file])
        elif usernames:
            cmd.extend(["-l", usernames])
        
        # Add password list
        if password_file:
            cmd.extend(["-P", password_file])
        elif passwords:
            cmd.extend(["-p", passwords])
        
        # Add additional options
        if options:
            for key, value in options.items():
                if key.startswith("-"):
                    if value:
                        cmd.append(f"{key} {value}")
                    else:
                        cmd.append(key)
                else:
                    if value:
                        cmd.extend([f"-{key}", value])
                    else:
                        cmd.append(f"-{key}")
        
        # Add target and service
        cmd.append(target)
        cmd.append(service)
        
        # Execute command
        try:
            process = await asyncio.create_subprocess_exec(
                *cmd,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE
            )
            
            stdout, stderr = await process.communicate()
            
            # Parse output
            output = stdout.decode()
            
            # Extract results
            credentials = []
            for line in output.split("\n"):
                if "login:" in line and "password:" in line:
                    # Extract username and password from output
                    try:
                        username = line.split("login:")[1].split("password:")[0].strip()
                        password = line.split("password:")[1].strip()
                        credentials.append({
                            "username": username,
                            "password": password
                        })
                    except:
                        continue
            
            # Create result object
            result = {
                "tool": "hydra",
                "target": target,
                "service": service,
                "username_file": username_file,
                "password_file": password_file,
                "usernames": usernames,
                "passwords": passwords,
                "tasks": tasks,
                "timeout": timeout,
                "timestamp": time.strftime("%Y-%m-%d %H:%M:%S"),
                "credentials": credentials,
                "output": output,
                "command": " ".join(cmd)
            }
            
            # Save result
            result_id = f"hydra_{service}_{target.replace('.', '_')}_{int(time.time())}"
            self.session_results[result_id] = result
            self._save_result(result_id, result)
            
            return result
            
        except Exception as e:
            return {
                "error": str(e),
                "tool": "hydra",
                "command": " ".join(cmd)
            }

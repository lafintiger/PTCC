import sys
import os
import json
import ipaddress
import nmap
import asyncio
from typing import Dict, List, Any, Optional, Union

# Add parent directory to path so we can import from config and utils
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
from config.settings import NMAP_PATH, SCAN_RESULTS_DIR
from utils.command import CommandExecutor

class NetworkScanner:
    """Handles network scanning operations using Nmap."""
    
    def __init__(self):
        """Initialize the network scanner."""
        self.nmap_scanner = nmap.PortScanner(nmap_search_path=(NMAP_PATH,))
        self.command_executor = CommandExecutor()
        self.scan_results = {}
    
    def scan_network(self, target: str, scan_type: str = "ping", arguments: Optional[str] = None) -> Dict[str, Any]:
        """
        Scan a network using Nmap.
        
        Args:
            target: Target network or host (e.g., "192.168.1.0/24" or "example.com")
            scan_type: Type of scan to perform (ping, quick, full, etc.)
            arguments: Additional Nmap arguments
            
        Returns:
            Scan results as a dictionary
        """
        # Define scan arguments based on scan type
        if scan_type == "ping":
            args = "-sn"  # Ping scan
        elif scan_type == "quick":
            args = "-T4 -F"  # Fast scan of top ports
        elif scan_type == "full":
            args = "-T4 -A -v"  # Comprehensive scan
        elif scan_type == "vuln":
            args = "-T4 --script vuln"  # Vulnerability scan
        else:
            args = "-sn"  # Default to ping scan
        
        # Add custom arguments if provided
        if arguments:
            args += f" {arguments}"
            
        # Perform the scan
        try:
            self.nmap_scanner.scan(hosts=target, arguments=args)
            
            # Process and store results
            hosts_dict = {}
            
            for host in self.nmap_scanner.all_hosts():
                host_info = {
                    "hostname": self.nmap_scanner[host].hostname(),
                    "state": self.nmap_scanner[host].state(),
                    "addresses": {},
                    "vendor": {},
                    "ports": []
                }
                
                # Get address information
                if "addresses" in self.nmap_scanner[host]:
                    host_info["addresses"] = self.nmap_scanner[host]["addresses"]
                
                # Get vendor information
                if "vendor" in self.nmap_scanner[host]:
                    host_info["vendor"] = self.nmap_scanner[host]["vendor"]
                
                # Get port information if available
                if "tcp" in self.nmap_scanner[host]:
                    for port, port_info in self.nmap_scanner[host]["tcp"].items():
                        host_info["ports"].append({
                            "port": port,
                            "protocol": "tcp",
                            "state": port_info["state"],
                            "service": port_info["name"],
                            "product": port_info.get("product", ""),
                            "version": port_info.get("version", ""),
                            "extrainfo": port_info.get("extrainfo", "")
                        })
                
                if "udp" in self.nmap_scanner[host]:
                    for port, port_info in self.nmap_scanner[host]["udp"].items():
                        host_info["ports"].append({
                            "port": port,
                            "protocol": "udp",
                            "state": port_info["state"],
                            "service": port_info["name"],
                            "product": port_info.get("product", ""),
                            "version": port_info.get("version", ""),
                            "extrainfo": port_info.get("extrainfo", "")
                        })
                
                hosts_dict[host] = host_info
            
            # Create result object
            result = {
                "scan_info": {
                    "target": target,
                    "scan_type": scan_type,
                    "arguments": args,
                    "timestamp": self.nmap_scanner.scanstats().get("timestr", ""),
                    "elapsed": self.nmap_scanner.scanstats().get("elapsed", ""),
                    "hosts_up": self.nmap_scanner.scanstats().get("uphosts", "0"),
                    "hosts_down": self.nmap_scanner.scanstats().get("downhosts", "0"),
                },
                "hosts": hosts_dict
            }
            
            # Save scan result
            # Convert elapsed time to integer, handling floating-point values
            try:
                elapsed_time = float(self.nmap_scanner.scanstats().get('elapsed', 0))
                elapsed_time_int = int(elapsed_time)
            except (ValueError, TypeError):
                elapsed_time_int = 0
                
            scan_id = f"nmap_{scan_type}_{target.replace('.', '_').replace('/', '_')}_{elapsed_time_int}"
            self.scan_results[scan_id] = result
            
            # Save to file
            self._save_scan_result(scan_id, result)
            
            return result
            
        except Exception as e:
            return {
                "error": str(e),
                "scan_info": {
                    "target": target,
                    "scan_type": scan_type,
                    "arguments": args
                }
            }
    
    async def scan_network_async(self, target: str, scan_type: str = "ping", arguments: Optional[str] = None) -> Dict[str, Any]:
        """
        Scan a network asynchronously using Nmap via command execution.
        
        Args:
            target: Target network or host
            scan_type: Type of scan to perform
            arguments: Additional Nmap arguments
            
        Returns:
            Scan results as a dictionary
        """
        # Define scan arguments based on scan type
        if scan_type == "ping":
            args = "-sn"  # Ping scan
        elif scan_type == "quick":
            args = "-T4 -F"  # Fast scan of top ports
        elif scan_type == "full":
            args = "-T4 -A -v"  # Comprehensive scan
        elif scan_type == "vuln":
            args = "-T4 --script vuln"  # Vulnerability scan
        else:
            args = "-sn"  # Default to ping scan
        
        # Add custom arguments if provided
        if arguments:
            args += f" {arguments}"
            
        # Define command to run
        command = f"{NMAP_PATH} {args} {target} -oX -"
        
        # Execute command asynchronously
        result = await self.command_executor.run_command_async(command)
        
        if result["success"]:
            # Parse XML output using nmap library
            try:
                self.nmap_scanner.analyse_nmap_xml_scan(result["stdout"])
                
                # Process and store results (similar to scan_network)
                hosts_dict = {}
                
                for host in self.nmap_scanner.all_hosts():
                    host_info = {
                        "hostname": self.nmap_scanner[host].hostname(),
                        "state": self.nmap_scanner[host].state(),
                        "addresses": {},
                        "vendor": {},
                        "ports": []
                    }
                    
                    # Get address information
                    if "addresses" in self.nmap_scanner[host]:
                        host_info["addresses"] = self.nmap_scanner[host]["addresses"]
                    
                    # Get vendor information
                    if "vendor" in self.nmap_scanner[host]:
                        host_info["vendor"] = self.nmap_scanner[host]["vendor"]
                    
                    # Get port information if available
                    if "tcp" in self.nmap_scanner[host]:
                        for port, port_info in self.nmap_scanner[host]["tcp"].items():
                            host_info["ports"].append({
                                "port": port,
                                "protocol": "tcp",
                                "state": port_info["state"],
                                "service": port_info["name"],
                                "product": port_info.get("product", ""),
                                "version": port_info.get("version", ""),
                                "extrainfo": port_info.get("extrainfo", "")
                            })
                    
                    if "udp" in self.nmap_scanner[host]:
                        for port, port_info in self.nmap_scanner[host]["udp"].items():
                            host_info["ports"].append({
                                "port": port,
                                "protocol": "udp",
                                "state": port_info["state"],
                                "service": port_info["name"],
                                "product": port_info.get("product", ""),
                                "version": port_info.get("version", ""),
                                "extrainfo": port_info.get("extrainfo", "")
                            })
                    
                    hosts_dict[host] = host_info
                
                # Create result object
                scan_result = {
                    "scan_info": {
                        "target": target,
                        "scan_type": scan_type,
                        "arguments": args,
                        "timestamp": self.nmap_scanner.scanstats().get("timestr", ""),
                        "elapsed": self.nmap_scanner.scanstats().get("elapsed", ""),
                        "hosts_up": self.nmap_scanner.scanstats().get("uphosts", "0"),
                        "hosts_down": self.nmap_scanner.scanstats().get("downhosts", "0"),
                    },
                    "hosts": hosts_dict,
                    "raw_command": result
                }
                
                # Save scan result
                # Convert elapsed time to integer, handling floating-point values
                try:
                    elapsed_time = float(self.nmap_scanner.scanstats().get('elapsed', 0))
                    elapsed_time_int = int(elapsed_time)
                except (ValueError, TypeError):
                    elapsed_time_int = 0
                    
                scan_id = f"nmap_{scan_type}_{target.replace('.', '_').replace('/', '_')}_{elapsed_time_int}"
                self.scan_results[scan_id] = scan_result
                
                # Save to file
                self._save_scan_result(scan_id, scan_result)
                
                return scan_result
                
            except Exception as e:
                return {
                    "error": f"Error parsing Nmap output: {str(e)}",
                    "scan_info": {
                        "target": target,
                        "scan_type": scan_type,
                        "arguments": args
                    },
                    "raw_command": result
                }
        else:
            return {
                "error": f"Nmap command failed: {result['stderr']}",
                "scan_info": {
                    "target": target,
                    "scan_type": scan_type,
                    "arguments": args
                },
                "raw_command": result
            }
    
    def get_scan_result(self, scan_id: str) -> Optional[Dict[str, Any]]:
        """
        Get a specific scan result by ID.
        
        Args:
            scan_id: ID of the scan to retrieve
            
        Returns:
            Scan result dictionary or None if not found
        """
        return self.scan_results.get(scan_id)
    
    def get_all_scan_results(self) -> Dict[str, Dict[str, Any]]:
        """
        Get all scan results.
        
        Returns:
            Dictionary of all scan results
        """
        return self.scan_results
    
    def _save_scan_result(self, scan_id: str, result: Dict[str, Any]) -> None:
        """
        Save scan result to a file.
        
        Args:
            scan_id: ID of the scan
            result: Scan result dictionary
        """
        try:
            # Create scan results directory if it doesn't exist
            os.makedirs(SCAN_RESULTS_DIR, exist_ok=True)
            
            # Save scan result to a JSON file
            file_path = os.path.join(SCAN_RESULTS_DIR, f"{scan_id}.json")
            with open(file_path, 'w') as f:
                json.dump(result, f, indent=2)
        except Exception as e:
            print(f"Error saving scan result: {e}")
    
    def load_scan_results(self) -> None:
        """Load all saved scan results from the scan results directory."""
        try:
            # Check if scan results directory exists
            if not os.path.exists(SCAN_RESULTS_DIR):
                return
            
            # Load all JSON files in the scan results directory
            for filename in os.listdir(SCAN_RESULTS_DIR):
                if filename.endswith(".json"):
                    file_path = os.path.join(SCAN_RESULTS_DIR, filename)
                    try:
                        with open(file_path, 'r') as f:
                            result = json.load(f)
                            scan_id = filename[:-5]  # Remove .json extension
                            self.scan_results[scan_id] = result
                    except Exception as e:
                        print(f"Error loading scan result {filename}: {e}")
        except Exception as e:
            print(f"Error loading scan results: {e}")
    
    def is_valid_target(self, target: str) -> bool:
        """
        Check if the target is valid (IP, IP range, or hostname).
        
        Args:
            target: Target to validate
            
        Returns:
            True if the target is valid, False otherwise
        """
        try:
            # Check if it's a valid IP address
            ipaddress.ip_address(target)
            return True
        except ValueError:
            try:
                # Check if it's a valid IP network
                ipaddress.ip_network(target, strict=False)
                return True
            except ValueError:
                # Check if it's a valid hostname (basic check)
                return all(c.isalnum() or c in "-." for c in target) and "." in target

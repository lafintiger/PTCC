import sys
import os
import json
import asyncio
import time
from typing import Dict, List, Any, Optional, Union

# Add parent directory to path so we can import from config and utils
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
from config.settings import (
    SCAN_RESULTS_DIR, OPENVAS_HOST, OPENVAS_PORT, 
    OPENVAS_USERNAME, OPENVAS_PASSWORD
)
from utils.command import CommandExecutor

class VulnerabilityScanner:
    """
    Handles vulnerability scanning operations 
    using various tools like OpenVAS and Nuclei.
    """
    
    def __init__(self):
        """Initialize the vulnerability scanner."""
        self.command_executor = CommandExecutor()
        self.scan_results = {}
    
    async def scan_with_nuclei(self, target: str, template: str = "", 
                         min_severity: str = "", additional_args: str = "") -> Dict[str, Any]:
        """
        Scan a target with Nuclei.
        
        Args:
            target: Target to scan (URL, IP, etc.)
            template: Template or template directory to use
            min_severity: Minimum severity of vulnerabilities to report
            additional_args: Additional command line arguments for Nuclei
            
        Returns:
            Scan results as a dictionary
        """
        # Build command
        cmd = [self.nuclei_path, "-target", target, "-json"]
        
        # Add template if provided
        if template:
            cmd.extend(["-t", template])
        
        # Add minimum severity if provided
        if min_severity:
            cmd.extend(["-severity", min_severity])
        
        # Add any additional arguments
        if additional_args:
            cmd.extend(additional_args.split())
        
        # Execute nuclei command
        try:
            process = await asyncio.create_subprocess_exec(
                *cmd,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE
            )
            
            stdout, stderr = await process.communicate()
            
            # Check for errors
            if process.returncode != 0:
                return {
                    "error": f"Nuclei process exited with code {process.returncode}: {stderr.decode()}"
                }
            
            # Process JSON output
            findings = []
            for line in stdout.decode().strip().split("\n"):
                if line:
                    try:
                        findings.append(json.loads(line))
                    except json.JSONDecodeError:
                        continue
            
            # Create result
            result = {
                "scan_info": {
                    "target": target,
                    "template": template,
                    "min_severity": min_severity,
                    "additional_args": additional_args,
                    "timestamp": time.strftime("%Y-%m-%d %H:%M:%S"),
                },
                "findings": findings
            }
            
            # Save scan result
            scan_id = f"nuclei_{target.replace(':', '_').replace('/', '_').replace('.', '_')}_{int(time.time())}"
            self.scan_results[scan_id] = result
            
            # Save to file
            self._save_scan_result(scan_id, result)
            
            return result
            
        except Exception as e:
            return {
                "error": str(e),
                "scan_info": {
                    "target": target,
                    "template": template,
                }
            }
    
    async def scan_with_openvas(self, target: str, scan_config: Optional[str] = None) -> Dict[str, Any]:
        """
        Scan target with OpenVAS vulnerability scanner.
        
        Args:
            target: Target IP or network
            scan_config: OpenVAS scan configuration ID
            
        Returns:
            Scan results as a dictionary
        """
        # Check if gvm-cli is installed (CLI for OpenVAS/GVM)
        if not self.command_executor.is_tool_installed("gvm-cli"):
            return {
                "error": "gvm-cli not installed. Please install GVM tools to use OpenVAS.",
                "scan_info": {
                    "target": target,
                    "scanner": "openvas"
                }
            }
        
        # Create target XML
        target_xml = f"""
        <create_target>
            <name>pentest_{target.replace('.', '_')}_{int(time.time())}</name>
            <hosts>{target}</hosts>
        </create_target>
        """
        
        # Create target command
        create_target_cmd = f'gvm-cli --gmp-username {OPENVAS_USERNAME} --gmp-password {OPENVAS_PASSWORD} socket --socketpath /var/run/gvmd/gvmd.sock --xml "{target_xml}"'
        
        # Execute command to create target
        create_result = await self.command_executor.run_command_async(create_target_cmd)
        
        if not create_result["success"]:
            return {
                "error": f"Failed to create OpenVAS target: {create_result['stderr']}",
                "scan_info": {
                    "target": target,
                    "scanner": "openvas"
                },
                "raw_command": create_result
            }
        
        try:
            # Extract target ID from response
            import xml.etree.ElementTree as ET
            target_id = ET.fromstring(create_result["stdout"]).find(".//id").text
            
            # Use full and fast scan config if none provided
            if not scan_config:
                # Get scan configs
                get_configs_cmd = f'gvm-cli --gmp-username {OPENVAS_USERNAME} --gmp-password {OPENVAS_PASSWORD} socket --socketpath /var/run/gvmd/gvmd.sock --xml "<get_configs/>"'
                configs_result = await self.command_executor.run_command_async(get_configs_cmd)
                
                if not configs_result["success"]:
                    return {
                        "error": f"Failed to get OpenVAS scan configs: {configs_result['stderr']}",
                        "scan_info": {
                            "target": target,
                            "scanner": "openvas"
                        },
                        "raw_command": configs_result
                    }
                
                # Find Full and Fast scan config ID
                config_root = ET.fromstring(configs_result["stdout"])
                for config in config_root.findall(".//config"):
                    if config.find("name").text == "Full and fast":
                        scan_config = config.find("id").text
                        break
            
            if not scan_config:
                return {
                    "error": "Could not find appropriate scan config",
                    "scan_info": {
                        "target": target,
                        "scanner": "openvas"
                    }
                }
            
            # Create task XML
            task_name = f"pentest_task_{target.replace('.', '_')}_{int(time.time())}"
            task_xml = f"""
            <create_task>
                <name>{task_name}</name>
                <target id="{target_id}"/>
                <config id="{scan_config}"/>
            </create_task>
            """
            
            # Create task command
            create_task_cmd = f'gvm-cli --gmp-username {OPENVAS_USERNAME} --gmp-password {OPENVAS_PASSWORD} socket --socketpath /var/run/gvmd/gvmd.sock --xml "{task_xml}"'
            
            # Execute command to create task
            task_result = await self.command_executor.run_command_async(create_task_cmd)
            
            if not task_result["success"]:
                return {
                    "error": f"Failed to create OpenVAS task: {task_result['stderr']}",
                    "scan_info": {
                        "target": target,
                        "scanner": "openvas"
                    },
                    "raw_command": task_result
                }
            
            # Extract task ID
            task_id = ET.fromstring(task_result["stdout"]).find(".//id").text
            
            # Start task
            start_task_xml = f'<start_task task_id="{task_id}"/>'
            start_task_cmd = f'gvm-cli --gmp-username {OPENVAS_USERNAME} --gmp-password {OPENVAS_PASSWORD} socket --socketpath /var/run/gvmd/gvmd.sock --xml "{start_task_xml}"'
            
            start_result = await self.command_executor.run_command_async(start_task_cmd)
            
            if not start_result["success"]:
                return {
                    "error": f"Failed to start OpenVAS task: {start_result['stderr']}",
                    "scan_info": {
                        "target": target,
                        "scanner": "openvas"
                    },
                    "raw_command": start_result
                }
            
            # Extract report ID from start task response
            report_id = ET.fromstring(start_result["stdout"]).find(".//report_id").text
            
            # Store info about the started scan
            scan_result = {
                "scan_info": {
                    "target": target,
                    "scanner": "openvas",
                    "scan_config": scan_config,
                    "timestamp": time.strftime("%Y-%m-%d %H:%M:%S"),
                    "target_id": target_id,
                    "task_id": task_id,
                    "report_id": report_id,
                    "status": "running"
                },
                "raw_command": {
                    "create_target": create_result,
                    "create_task": task_result,
                    "start_task": start_result
                }
            }
            
            # Save scan result
            scan_id = f"openvas_{target.replace('.', '_').replace('/', '_')}_{int(time.time())}"
            self.scan_results[scan_id] = scan_result
            
            # Save to file
            self._save_scan_result(scan_id, scan_result)
            
            return scan_result
            
        except Exception as e:
            return {
                "error": f"Error setting up OpenVAS scan: {str(e)}",
                "scan_info": {
                    "target": target,
                    "scanner": "openvas"
                },
                "raw_command": create_result
            }
    
    async def get_openvas_report(self, report_id: str, format: str = "xml") -> Dict[str, Any]:
        """
        Get a specific OpenVAS scan report.
        
        Args:
            report_id: ID of the report to retrieve
            format: Report format (xml, pdf, etc.)
            
        Returns:
            Report data
        """
        # Get report XML
        report_xml = f'<get_reports report_id="{report_id}" format_id="{format}"/>'
        report_cmd = f'gvm-cli --gmp-username {OPENVAS_USERNAME} --gmp-password {OPENVAS_PASSWORD} socket --socketpath /var/run/gvmd/gvmd.sock --xml "{report_xml}"'
        
        # Execute command to get report
        report_result = await self.command_executor.run_command_async(report_cmd)
        
        if report_result["success"]:
            try:
                # Parse XML report
                report_root = ET.fromstring(report_result["stdout"])
                report_element = report_root.find(".//report")
                
                if report_element is not None:
                    # Extract report data
                    findings = []
                    for result in report_element.findall(".//result"):
                        finding = {
                            "name": self._get_xml_text(result, ".//name"),
                            "severity": self._get_xml_text(result, ".//severity"),
                            "description": self._get_xml_text(result, ".//description"),
                            "cve": self._get_xml_text(result, ".//cve"),
                            "cvss_base": self._get_xml_text(result, ".//cvss_base"),
                            "threat": self._get_xml_text(result, ".//threat"),
                            "port": self._get_xml_text(result, ".//port"),
                            "nvt": self._get_xml_text(result, ".//nvt/oid")
                        }
                        findings.append(finding)
                    
                    # Create result object
                    result_data = {
                        "report_id": report_id,
                        "timestamp": time.strftime("%Y-%m-%d %H:%M:%S"),
                        "findings": findings,
                        "raw_report": report_result["stdout"]
                    }
                    
                    return result_data
                else:
                    return {
                        "error": "No report data found",
                        "report_id": report_id,
                        "raw_report": report_result["stdout"]
                    }
                    
            except Exception as e:
                return {
                    "error": f"Error parsing OpenVAS report: {str(e)}",
                    "report_id": report_id,
                    "raw_report": report_result["stdout"]
                }
        else:
            return {
                "error": f"Failed to get OpenVAS report: {report_result['stderr']}",
                "report_id": report_id,
                "raw_command": report_result
            }
    
    def _get_xml_text(self, element, xpath, default=""):
        """Helper method to safely extract text from XML element."""
        result = element.find(xpath)
        return result.text if result is not None and result.text is not None else default
    
    async def scan_with_nmap_vuln(self, target: str) -> Dict[str, Any]:
        """
        Scan target for vulnerabilities using Nmap NSE scripts.
        
        Args:
            target: Target IP or hostname
            
        Returns:
            Scan results as a dictionary
        """
        # Build command
        command = f"nmap -sV --script vuln {target} -oX -"
        
        # Execute command
        result = await self.command_executor.run_command_async(command)
        
        if result["success"]:
            try:
                # Process the XML output using nmap library
                import nmap
                scanner = nmap.PortScanner()
                scanner.analyse_nmap_xml_scan(result["stdout"])
                
                # Extract vulnerability information
                vulnerabilities = []
                
                for host in scanner.all_hosts():
                    host_vulns = []
                    
                    if 'tcp' in scanner[host]:
                        for port in scanner[host]['tcp']:
                            port_info = scanner[host]['tcp'][port]
                            
                            # Check for script results
                            if 'script' in port_info:
                                for script_name, script_output in port_info['script'].items():
                                    if script_name.startswith('vuln'):
                                        host_vulns.append({
                                            "port": port,
                                            "protocol": "tcp",
                                            "service": port_info['name'],
                                            "script": script_name,
                                            "output": script_output
                                        })
                    
                    vulnerabilities.append({
                        "host": host,
                        "vulnerabilities": host_vulns
                    })
                
                # Create result object
                scan_result = {
                    "scan_info": {
                        "target": target,
                        "scanner": "nmap_vuln",
                        "timestamp": time.strftime("%Y-%m-%d %H:%M:%S"),
                    },
                    "vulnerabilities": vulnerabilities,
                    "raw_command": result
                }
                
                # Save scan result
                scan_id = f"nmap_vuln_{target.replace('.', '_').replace('/', '_')}_{int(time.time())}"
                self.scan_results[scan_id] = scan_result
                
                # Save to file
                self._save_scan_result(scan_id, scan_result)
                
                return scan_result
                
            except Exception as e:
                return {
                    "error": f"Error parsing Nmap vulnerabilities output: {str(e)}",
                    "scan_info": {
                        "target": target,
                        "scanner": "nmap_vuln"
                    },
                    "raw_command": result
                }
        else:
            return {
                "error": f"Nmap vulnerability scan failed: {result['stderr']}",
                "scan_info": {
                    "target": target,
                    "scanner": "nmap_vuln"
                },
                "raw_command": result
            }
    
    def get_scan_result(self, scan_id: str) -> Optional[Dict[str, Any]]:
        """
        Get a specific scan result by ID.
        
        Args:
            scan_id: ID of the scan to retrieve
            
        Returns:
            Scan result dictionary or None if not found
        """
        return self.scan_results.get(scan_id)
    
    def get_all_scan_results(self) -> Dict[str, Dict[str, Any]]:
        """
        Get all scan results.
        
        Returns:
            Dictionary of all scan results
        """
        return self.scan_results
    
    def _save_scan_result(self, scan_id: str, result: Dict[str, Any]) -> None:
        """
        Save scan result to a file.
        
        Args:
            scan_id: ID of the scan
            result: Scan result dictionary
        """
        try:
            # Create scan results directory if it doesn't exist
            os.makedirs(SCAN_RESULTS_DIR, exist_ok=True)
            
            # Save scan result to a JSON file
            file_path = os.path.join(SCAN_RESULTS_DIR, f"{scan_id}.json")
            with open(file_path, 'w') as f:
                json.dump(result, f, indent=2)
        except Exception as e:
            print(f"Error saving scan result: {e}")
    
    def load_scan_results(self) -> None:
        """Load all saved scan results from the scan results directory."""
        try:
            # Check if scan results directory exists
            if not os.path.exists(SCAN_RESULTS_DIR):
                return
            
            # Load all JSON files in the scan results directory
            for filename in os.listdir(SCAN_RESULTS_DIR):
                if filename.endswith(".json") and ("nuclei_" in filename or "openvas_" in filename or "nmap_vuln_" in filename):
                    file_path = os.path.join(SCAN_RESULTS_DIR, filename)
                    try:
                        with open(file_path, 'r') as f:
                            result = json.load(f)
                            scan_id = filename[:-5]  # Remove .json extension
                            self.scan_results[scan_id] = result
                    except Exception as e:
                        print(f"Error loading scan result {filename}: {e}")
        except Exception as e:
            print(f"Error loading scan results: {e}")
